from fastapi import FastAPI, HTTPException, BackgroundTasks
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
import os
import logging
from ragc_core.hybrid_rag import HybridRAG
from ragc_core.config import RAGConfig
from ragc_core.document_processor import DocumentProcessor

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("representative_agent_api")

app = FastAPI(
    title="Representative Agent API",
    description="API for communicating with the Representative Agent (Hybrid RAG System)",
    version="1.0.0"
)

# Global RAG system instance
rag_system: Optional[HybridRAG] = None

class QueryRequest(BaseModel):
    query: str
    top_k: Optional[int] = 5

class DocumentChunk(BaseModel):
    text: str
    metadata: Dict[str, Any]
    score: Optional[float] = None

class QueryResponse(BaseModel):
    answer: str
    retrieved_documents: List[Dict[str, Any]]
    query: str

class RetrieveResponse(BaseModel):
    query: str
    documents: List[Dict[str, Any]]

@app.on_event("startup")
async def startup_event():
    global rag_system
    logger.info("Initializing Representative Agent...")
    
    # Load configuration from environment variables
    config = RAGConfig(
        gemini_api_key=os.getenv("GEMINI_API_KEY"),
        model_name=os.getenv("MODEL_NAME", "gemini-2.0-flash-exp"),
        top_k=int(os.getenv("TOP_K", "5")),
        merge_strategy=os.getenv("MERGE_STRATEGY", "weighted")
    )
    
    try:
        rag_system = HybridRAG(config)
        logger.info("Representative Agent initialized successfully")
    except Exception as e:
        logger.error(f"Failed to initialize Representative Agent: {e}")
        # We don't raise here to allow the server to start, but endpoints will fail

@app.get("/")
async def root():
    """Root endpoint with welcome message"""
    return {
        "message": "Welcome to the Representative Agent API",
        "docs_url": "/docs",
        "status_url": "/status"
    }

@app.get("/status")
async def get_status():
    """Get the status of the agent"""
    if rag_system:
        stats = rag_system.get_system_stats()
        return {
            "status": "ready",
            "stats": stats
        }
    else:
        return {
            "status": "initializing_or_error",
            "message": "RAG system not initialized"
        }

@app.post("/query", response_model=QueryResponse)
async def query_agent(request: QueryRequest):
    """
    Ask a question to the agent.
    Returns the answer generated by the LLM and the retrieved context.
    """
    if not rag_system:
        raise HTTPException(status_code=503, detail="Agent not initialized")
    
    try:
        result = rag_system.query(request.query, top_k=request.top_k)
        return QueryResponse(
            answer=result["answer"],
            retrieved_documents=result["retrieved_documents"],
            query=request.query
        )
    except Exception as e:
        logger.error(f"Query error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/retrieve", response_model=RetrieveResponse)
async def retrieve_documents(request: QueryRequest):
    """
    Retrieve relevant documents without generating an answer.
    Useful for other agents that want to process the information themselves.
    """
    if not rag_system:
        raise HTTPException(status_code=503, detail="Agent not initialized")
    
    try:
        docs = rag_system.retrieve(request.query, top_k=request.top_k)
        return RetrieveResponse(
            query=request.query,
            documents=docs
        )
    except Exception as e:
        logger.error(f"Retrieval error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/index")
async def index_documents(background_tasks: BackgroundTasks, file_paths: List[str]):
    """
    Trigger indexing of documents from local paths.
    """
    if not rag_system:
        raise HTTPException(status_code=503, detail="Agent not initialized")
    
    # Validate files exist
    valid_paths = [p for p in file_paths if os.path.exists(p)]
    if not valid_paths:
        raise HTTPException(status_code=400, detail="No valid file paths provided")
        
    background_tasks.add_task(_process_and_index, valid_paths)
    
    return {
        "message": f"Indexing started for {len(valid_paths)} files",
        "files": valid_paths
    }

def _process_and_index(file_paths: List[str]):
    """Helper to process and index documents in background"""
    if not rag_system:
        return
        
    processor = DocumentProcessor()
    try:
        chunks = processor.process_multiple_documents(file_paths)
        rag_system.add_documents(chunks)
        logger.info(f"Successfully indexed {len(chunks)} chunks from {len(file_paths)} files")
    except Exception as e:
        logger.error(f"Indexing error: {e}")

@app.get("/documents")
async def list_documents():
    """
    List all documents currently indexed in the system.
    Useful for verifying knowledge accumulation.
    """
    if not rag_system:
        raise HTTPException(status_code=503, detail="Agent not initialized")
    
    try:
        # Access vector store directly to get document list
        # Note: This depends on the implementation of VectorRAG
        # We'll assume we can get count or list from stats
        stats = rag_system.get_system_stats()
        count = stats["vector_rag"]["total_documents"]
        
        # To get actual list, we might need to query the collection
        # For now, we return the count and stats
        return {
            "count": count,
            "stats": stats,
            "message": "To see actual content, use the retrieve endpoint."
        }
    except Exception as e:
        logger.error(f"Failed to list documents: {e}")
        raise HTTPException(status_code=500, detail=str(e))
