from fastapi import FastAPI, HTTPException, BackgroundTasks, UploadFile, File, Form
from pydantic import BaseModel
from typing import List, Optional, Dict, Any, Union
import os
import json
import shutil
import logging
from ragc_core.hybrid_rag import HybridRAG
from ragc_core.config import RAGConfig
from ragc_core.document_processor import DocumentProcessor
from evaluation.communication_evaluator import CommunicationEvaluator

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("representative_agent_api")

app = FastAPI(
    title="Representative Agent API",
    description="API for communicating with the Representative Agent (Hybrid RAG System)",
    version="1.0.0"
)

# Global RAG system instance
rag_system: Optional[HybridRAG] = None

class QueryRequest(BaseModel):
    query: str
    top_k: Optional[int] = 5
    rag_method: Optional[str] = "Hybrid RAG"
    temperature: Optional[float] = 0.7

class DocumentChunk(BaseModel):
    text: str
    metadata: Dict[str, Any]
    score: Optional[float] = None

class QueryResponse(BaseModel):
    answer: str
    retrieved_documents: List[Dict[str, Any]]
    query: str
    rag_method: str

class RetrieveResponse(BaseModel):
    query: str
    documents: List[Dict[str, Any]]
    rag_method: str

class EvaluationRequest(BaseModel):
    document_paths: List[str]
    student_persona: str = "Novice"
    aggregate: bool = False

@app.on_event("startup")
async def startup_event():
    global rag_system
    logger.info("Initializing Representative Agent...")
    
    # Load configuration from environment variables
    config = RAGConfig(
        gemini_api_key=os.getenv("GEMINI_API_KEY"),
        model_name=os.getenv("MODEL_NAME", "gemini-2.0-flash-exp"),
        top_k=int(os.getenv("TOP_K", "5")),
        merge_strategy=os.getenv("MERGE_STRATEGY", "weighted")
    )
    
    try:
        rag_system = HybridRAG(config)
        logger.info("Representative Agent initialized successfully")
    except Exception as e:
        logger.error(f"Failed to initialize Representative Agent: {e}")
        # We don't raise here to allow the server to start, but endpoints will fail

@app.get("/")
async def root():
    """Root endpoint with welcome message"""
    return {
        "message": "Welcome to the Representative Agent API",
        "docs_url": "/docs",
        "status_url": "/status"
    }

@app.get("/status")
async def get_status():
    """Get the status of the agent"""
    if rag_system:
        stats = rag_system.get_system_stats()
        return {
            "status": "ready",
            "api_key_configured": True,
            "stats": stats
        }
    else:
        # Check if API key is in env even if system failed to init
        api_key_in_env = bool(os.getenv("GEMINI_API_KEY"))
        return {
            "status": "initializing_or_error",
            "api_key_configured": api_key_in_env,
            "message": "RAG system not initialized"
        }

@app.post("/query", response_model=QueryResponse)
async def query_agent(request: QueryRequest):
    """
    Ask a question to the agent.
    Returns the answer generated by the LLM and the retrieved context.
    """
    if not rag_system:
        raise HTTPException(status_code=503, detail="Agent not initialized")
    
    try:
        result = rag_system.query(
            request.query, 
            top_k=request.top_k,
            rag_method=request.rag_method,
            temperature=request.temperature
        )
        return QueryResponse(
            answer=result["answer"],
            retrieved_documents=result["retrieved_documents"],
            query=request.query,
            rag_method=request.rag_method
        )
    except Exception as e:
        logger.error(f"Query error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/retrieve", response_model=RetrieveResponse)
async def retrieve_documents(request: QueryRequest):
    """
    Retrieve relevant documents without generating an answer.
    Useful for other agents that want to process the information themselves.
    """
    if not rag_system:
        raise HTTPException(status_code=503, detail="Agent not initialized")
    
    try:
        docs = rag_system.retrieve(
            request.query, 
            top_k=request.top_k,
            rag_method=request.rag_method
        )
        return RetrieveResponse(
            query=request.query,
            documents=docs,
            rag_method=request.rag_method
        )
    except Exception as e:
        logger.error(f"Retrieval error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/index")
async def index_documents(background_tasks: BackgroundTasks, file_paths: List[str]):
    """
    Trigger indexing of documents from local paths.
    """
    if not rag_system:
        raise HTTPException(status_code=503, detail="Agent not initialized")
    
    # Validate files exist
    valid_paths = [p for p in file_paths if os.path.exists(p)]
    if not valid_paths:
        raise HTTPException(status_code=400, detail="No valid file paths provided")
        
    background_tasks.add_task(_process_and_index, valid_paths)
    
    return {
        "message": f"Indexing started for {len(valid_paths)} files",
        "files": valid_paths
    }

@app.post("/upload")
async def upload_files(background_tasks: BackgroundTasks, clear_existing: bool = False, files: List[UploadFile] = File(...)):
    """
    Upload files and trigger indexing.
    Optionally clear existing documents before indexing.
    """
    if not rag_system:
        raise HTTPException(status_code=503, detail="Agent not initialized")
    
    # Clear existing documents if requested
    if clear_existing:
        logger.info("Clearing all existing documents before upload...")
        rag_system.clear_all()
        
    upload_dir = "temp_uploads"
    os.makedirs(upload_dir, exist_ok=True)
    
    saved_paths = []
    
    try:
        for file in files:
            file_path = os.path.join(upload_dir, file.filename)
            with open(file_path, "wb") as buffer:
                shutil.copyfileobj(file.file, buffer)
            saved_paths.append(os.path.abspath(file_path))
            
        # Trigger indexing in background
        background_tasks.add_task(_process_and_index, saved_paths)
        
        mode = "Cleared existing and uploading" if clear_existing else "Appending"
        return {
            "message": f"{mode} {len(files)} files",
            "files": [f.filename for f in files],
            "clear_existing": clear_existing
        }
    except Exception as e:
        logger.error(f"Upload error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/clear")
async def clear_all_documents():
    """
    Clear all documents from RAG system
    """
    if not rag_system:
        raise HTTPException(status_code=503, detail="Agent not initialized")
    
    try:
        rag_system.clear_all()
        logger.info("All documents cleared from RAG system")
        return {
            "message": "All documents cleared successfully",
            "status": "success"
        }
    except Exception as e:
        logger.error(f"Clear error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/evaluate")
async def evaluate_communication(
    document_paths: str = Form(...),  # JSON string
    student_persona: str = Form("Novice"),
    aggregate: bool = Form(False),
    compare_methods: bool = Form(False),
    evaluation_file: Optional[UploadFile] = File(None)
):
    """
    Evaluate communication effectiveness.
    Supports both auto-generated questions and pre-defined evaluation.json.
    Can compare multiple RAG methods (Vector, Graph, Hybrid).
    """
    if not rag_system:
        raise HTTPException(status_code=503, detail="Agent not initialized")
    
    try:
        # Parse document paths from JSON string
        paths = json.loads(document_paths)
        
        # Parse evaluation file if provided
        qa_pairs = None
        if evaluation_file:
            logger.info(f"Using evaluation file: {evaluation_file.filename}")
            content = await evaluation_file.read()
            eval_data = json.loads(content)
            
            if isinstance(eval_data, list):
                qa_pairs = eval_data
            elif isinstance(eval_data, dict):
                qa_pairs = eval_data.get("questions", [])
            else:
                logger.warning("Invalid evaluation file format. Expected list or dict.")
                qa_pairs = []
                
            logger.info(f"Loaded {len(qa_pairs)} pre-defined questions from evaluation file")
        
        # Initialize evaluator
        doc_processor = DocumentProcessor()
        evaluator = CommunicationEvaluator(rag_system, doc_processor)
        
        # Determine methods to evaluate
        methods = ["Vector RAG", "Graph RAG", "Hybrid RAG"] if compare_methods else ["Hybrid RAG"]
        logger.info(f"Running evaluation with methods: {methods}")
        
        all_results = []
        
        # Run evaluation
        if aggregate or len(paths) > 1:
            # Evaluate all documents together
            for method in methods:
                logger.info(f"Evaluating aggregated docs with {method}...")
                result = evaluator.evaluate_communication(
                    paths, 
                    student_persona,
                    qa_pairs=qa_pairs,
                    rag_method=method
                )
                all_results.append(result)
        else:
            # Evaluate each document separately
            for path in paths:
                for method in methods:
                    logger.info(f"Evaluating {path} with {method}...")
                    result = evaluator.evaluate_communication(
                        path, 
                        student_persona,
                        qa_pairs=qa_pairs,
                        rag_method=method
                    )
                    all_results.append(result)
                    
        return {"results": all_results}
            
    except Exception as e:
        logger.error(f"Evaluation error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

def _process_and_index(file_paths: List[str]):
    """Helper to process and index documents in background"""
    if not rag_system:
        return
        
    processor = DocumentProcessor()
    try:
        chunks = processor.process_multiple_documents(file_paths)
        rag_system.add_documents(chunks)
        logger.info(f"Successfully indexed {len(chunks)} chunks from {len(file_paths)} files")
    except Exception as e:
        logger.error(f"Indexing error: {e}")

@app.get("/documents")
async def list_documents():
    """
    List all documents currently indexed in the system.
    Useful for verifying knowledge accumulation.
    """
    if not rag_system:
        raise HTTPException(status_code=503, detail="Agent not initialized")
    
    try:
        # Access vector store directly to get document list
        stats = rag_system.get_system_stats()
        files = rag_system.get_indexed_files()
        
        return {
            "count": len(files),
            "files": files,
            "stats": stats,
            "message": f"Found {len(files)} indexed documents."
        }
    except Exception as e:
        logger.error(f"Failed to list documents: {e}")
        raise HTTPException(status_code=500, detail=str(e))
